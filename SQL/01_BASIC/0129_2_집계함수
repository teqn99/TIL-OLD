# Oracle SQL Developer

[집계함수, 그룹함수, 다중행 함수]
- 인수(argument)는 컬럼
  - sum(): 전체합계
  - avg(): 평균
  - min(): 최소값
  - max(): 최대값
  - stddev(): 표준편차
  - variance(): 분산
  - count(): 개수
        - 인수: 
            - 컬럼명: null을 제외한 개수
            -  *: 총 행수(null을 포함)

- count(*) 를 제외하고 모든 집계함수는 null은 빼고 계산한다.
- sum, avg, stddev, variance: number 타입에만 사용가능.
- min, max, count :  모든 타입에 다 사용가능.



[group by 절]
- 특정 컬럼(들)의 값별로 나눠 집계할 때 나누는 기준컬럼을 지정하는 구문.
	- 예) 업무별 급여평균. 부서-업무별 급여 합계. 성별 나이평균
- 구문: group by 컬럼명 [, 컬럼명]
	- 컬럼: 분류형(범주형, 명목형) - 부서별 급여 평균, 성별 급여 합계
	- select의 where 절 다음에 기술한다.
	- select 절에는 group by 에서 선언한 컬럼들만 집계함수와 같이 올 수 있다
  ex)
  select  job,
        sum(salary) 총합계,
        round(avg(salary), 2) 평균,
        min(salary) 최소값,
        max(salary) 최대값,
        round(stddev(salary), 2) 표준편차,
        round(variance(salary), 2) 분산,
        count(*) 직원수
  from    emp
  group by job; -> job이 총 19개 이므로 집계 결과가 19개가 나올 것
  -> group by를 통해 뒤에 나온 job의 그룹을 나누어 위의 select 구문을 수행
  
  
  
[having 절]
- 집계결과에 대한 행 제약 조건
- group by 다음 order by 전에 온다.
- 구문
    having 제약조건  -- 연산자는 where절의 연산자를 사용한다. 피연산자는 집계함수(의 결과)
    -> 제약조건의 집계 결과르 확인하여 true인 결과만을 group by절로 가져온다.
    (group 함수에서는 where절을 통해 조건을 달 수 없다.)
  ex)
  select  dept_name,
        count(*)
  from    emp
  group by dept_name
  having count(*) >= 10
  order by 1;

  
  
[rollup : group by의 확장]
  - group by로 묶어 집계할 경우 누적집계(중간집계나 총집계)를 부분 집계에 추가해서 조회한다.
  - 구문 : group by rollup(컬럼명 [,컬럼명,..])



[grouping(), grouping_id()]
  - rollup 이용한 집계시 컬럼이 각 행의 집계에 참여했는지 여부를 반환하는 함수. (rollup을 썼을때만 사용)
  - case/decode를 이용해 레이블을 붙여 가독성을 높일 수 있다.
  - 반환값
	- 0 : 참여한 경우
	- 1 : 참여 안한 경우.
 
 1. grouping() 함수
  - 구문: grouping(groupby컬럼)
  - select 절에 사용되며 rollup이나 cube와 함께 사용해야 한다.
  - group by의 컬럼이 집계함수의 집계에 참여했는지 여부를 반환 
	- 반환값 0 : 참여함(부분집계함수 결과), 반환값 1: 참여 안함(누적집계의 결과)
  - 누적 집계인지 부분집계의 결과인지를 알려주는 알 수 있다. 

 2. grouping_id 함수
  - 구문: grouping_id(groupby 컬럼, ..)
  - 전달한 컬럼이 집계에 사용되었는지 여부 2진수(0: 참여 안함, 1: 참여함)로 반환 한뒤 10진수로 변환해서 반환한다.
  ex) grouping_id(dept_name, job) -> dept_name의 참여여부: 2^1, job의 참여여부: 2^0
                                  -> 참여 했다 = 0 / 참여 안했다 = 1
                                  -> dept_name, job 모두 참여 -> 2^1 * 0 + 2^0 * 0 = 0
                                  -> dept_name, job 모두 참여안함 -> 2^1 * 1 + 2^0 * 1 = 3
                                  -> dept_name만 참여 -> 2^1 * 0 + 2^0 * 1 = 1
  -> grouping_id 함수 정리:
    1. 표현식의 값이 NULL인 여부에 따라 0, 1을 리턴한다.
      grouping_id(dept_id): dept_id가 조회되면 0, NULL이면 1을 리턴한다.
      grouping_id(job_id): job_id 조회되면 0, NULL이면 1을 리턴한다.
      
    2. 비트 벡터로 변환한다. (2진수화)
      둘 다 조회되면: 00
      dept_id가 조회되고, job_id가 NULL이면: 01
      dept_id가 NULL이고, job_id가 조회되면: 10
      둘 다 NULL이면: 11
      
    3. 10진수로 변환한 뒤 리턴한다.
      00 -> 0
      01 -> 1
      10 -> 2
      11 -> 3
    
    
    
    
    
    
    
    
